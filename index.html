<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Adaptive Grid Layout with Counters</title>
    <style>
        * {
            box-sizing: border-box;
            color-scheme: dark;
        }
        @font-face {
          font-family: 'Roboto';
          src: url('/home/amnesia/Persistent/Tor Browser/font/RobotoCondensed-VariableFont_wght.ttf')
          }

        body {
            font-family: 'Roboto', sans-serif;
            font-size: 23px;
            line-height: 1.4;
            color: #e6ddd1;
            display: flex;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
        }

        /* Container for columns 1 and 2 */
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: repeat(100, auto);
            gap: 0px;
            padding: 3.5px;
            overflow-y: auto;
            width: 70%;
            margin-right: 0px;
            max-height: 100vh;
        }

        .grid-item {
            padding: 10px;
            border: 1px solid #ccc;
        }

        .editable {
            background-color: #0d0d0d;
            box-shadow: inset 0 7px 12px rgba(0, 0, 0, 1);
        }

        .readonly {
            background-color: #202123;
            color: #d1cec9;
        }

        /* Fixed third column */
        .column-3 {
            position: relative;
            width: 30%;
            max-height: 100vh;
            overflow-y: auto;
            padding: 3.5px;
            border: 1px solid #ccc;
            display: grid;
            grid-template-rows: repeat(100, auto);
        }

        /* Fixed buttons and counters on top */
        .button-container {
            position: fixed;
            transform: translate(-50%, -50%);
            top: 3%;
            left: 50%;
            display: flex;
            gap: 15px;
            font-weight: 700;
            background-color: black;
            border: 1px solid #ccc;
            padding: 0px 12px;
            box-shadow: 3px 2px 2px rgba(255, 0, 0, 0.2);
        }

        .button-container button {
            margin: 4px;
            font-size: 15px;
            font-weight: bold;
            line-height: 1.2;
        }

        /* Counter style */
        .counter {
            display: flex;
            flex-direction: column;
            gap: 1px;
            font-size: 30px;
        }
        
        .column-1-cell {

        }

        /* Image thumbnail styles */
        .thumb {
            display: inline-block;
            width: 1.2em;
            height: 1.2em;
            cursor: pointer;
            vertical-align: middle;
            margin: 0 2px;
        }
        
        .thumb::before {
            content: "üñºÔ∏è";
            font-size: 1em;
        }

        /* Overlay styles */
        #overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        #overlay img {
            max-width: 90%;
            max-height: 90%;
            box-shadow: 0 0 20px #000;
        }

        @media (max-width: 1200px) {
            body {
                flex-direction: column;
            }

            .grid-container, .column-3 {
                width: 100%;
                height: 100%;
                margin-right: 0;
            }
        }
    </style>
</head>
<body>

    <!-- Image overlay -->
    <div id="overlay" onclick="this.style.display='none'"><img></div>

    <div class="button-container">
        <button onclick="formatText('bold')">Bold</button>
        <button onclick="formatText('italic')">Italic</button>
        <input type="file" id="fileInput" style="display: none;" />
        
        <!-- Word and Sentence Counter -->
        <div class="counter">
            <div><span id="wordCount">0</span> / <span id="sentenceCount">0</span></div>
        </div>
        <button onclick="saveData()">Save</button>
        <button onclick="loadData()">Load</button>  
    </div>

    <!-- First and Second Column -->
    <div class="grid-container" id="grid">
        <!-- Columns 1 and 2 will be generated via JavaScript -->
    </div>

    <!-- Third Column -->
    <div class="column-3" id="column-3">
        <!-- Odd and even rows in Column 3 generated dynamically -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        const grid = document.getElementById('grid');
        const column3 = document.getElementById('column-3');
        let currentRow = null;
        let column3Data = {};
        const wordCountSpan = document.getElementById('wordCount');
        const sentenceCountSpan = document.getElementById('sentenceCount');

        // Image viewer variables
        let overlay = document.getElementById("overlay");
        let big = overlay.querySelector("img");
        let images = [];
        let current = 0;

        // Word and sentence limits
        const maxWordsColumn1 = 1000;
        const maxSentencesColumn1 = 50;
        const maxWordsColumn3Even = 1000;
        const maxSentencesColumn3Even = 50;

        // Toolbar buttons for formatting (bold and italic)
        function formatText(command) {
            document.execCommand(command, false, null);
        }

        // Function to count words in a string
        function countWords(text) {
            return text.replace(/\n+/g, ' ').trim().split(/\s+/).filter(word => word.length > 0).length;
        }

        // Function to count sentences in a string
        function countSentences(text) {
            return text.split(/[.!?]+/).filter(sentence => sentence.trim().length > 0).length;
        }

        // Update word and sentence counters
        function updateCounters(text) {
            const wordCount = countWords(text);
            const sentenceCount = countSentences(text);
            wordCountSpan.textContent = wordCount;
            sentenceCountSpan.textContent = sentenceCount;
        }

        // Function to enforce word and sentence limits
        function enforceLimits(element, isColumn1) {
            const text = element.textContent.replace(/\n+/g, ' ').trim();
            const wordCount = countWords(text);
            const sentenceCount = countSentences(text);
            const maxWords = isColumn1 ? maxWordsColumn1 : maxWordsColumn3Even;
            const maxSentences = isColumn1 ? maxSentencesColumn1 : maxSentencesColumn3Even;

            if (wordCount > maxWords || sentenceCount > maxSentences) {
                const trimmedText = text
                    .split('.')
                    .map(sentence => sentence.trim())
                    .slice(0, maxSentences)
                    .join('. ') + '.'
                    .split(/\s+/)
                    .slice(0, maxWords)
                    .join(' ');

                element.textContent = trimmedText.trim();
            }
        }

        // Image viewer functions
        function openImage(imageSrc) {
            // Find the image in our images array or add it
            let index = images.indexOf(imageSrc);
            if (index === -1) {
                images.push(imageSrc);
                index = images.length - 1;
            }
            
            current = index;
            big.src = images[current];
            overlay.style.display = "flex";
        }

        // Rebind all thumb click handlers
        function rebindThumbs() {
            document.querySelectorAll('.thumb').forEach(thumb => {
                // Remove existing handler to avoid duplicates
                thumb.onclick = null;
                
                // Add click handler
                thumb.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const imageSrc = this.dataset.src;
                    if (imageSrc) {
                        openImage(imageSrc);
                    }
                };
            });
        }

        // Handle paste events for images
        document.addEventListener("paste", e => {
            let hasImage = false;
            
            [...e.clipboardData.items].forEach(item => {
                if (item.type.startsWith("image")) {
                    hasImage = true;
                    e.preventDefault(); // Prevent default paste behavior
                    
                    const file = item.getAsFile();
                    const reader = new FileReader();
                    
                    reader.onload = function(event) {
                        const imageSrc = event.target.result; // Base64 data URL
                        
                        // Create thumb span instead of img
                        const thumbSpan = document.createElement('span');
                        thumbSpan.className = 'thumb';
                        thumbSpan.dataset.src = imageSrc;
                        
                        // Insert using execCommand with immediate cursor positioning
                        const thumbHtml = `<span class="thumb" data-src="${imageSrc}"></span>&nbsp;`;
                        document.execCommand('insertHTML', false, thumbHtml);
                        
                        // Force cursor to move to the end after insertion
                        setTimeout(() => {
                            const selection = window.getSelection();
                            const activeElement = document.activeElement;
                            
                            if (activeElement && activeElement.contentEditable === 'true') {
                                // Move cursor to the very end of the active element
                                const range = document.createRange();
                                range.selectNodeContents(activeElement);
                                range.collapse(false); // Collapse to end
                                
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                        }, 10);
                        
                        // Add to images array and rebind
                        if (!images.includes(imageSrc)) {
                            images.push(imageSrc);
                        }
                        rebindThumbs();
                    };
                    
                    reader.readAsDataURL(file); // Convert to base64
                }
            });
            
            if (hasImage) {
                e.preventDefault(); // Prevent the default paste if we handled an image
            }
        });

        // Keyboard navigation for image overlay
        document.addEventListener("keydown", e => {
            if (overlay.style.display === "flex") {
                if (e.key === "Escape") overlay.style.display = "none";
                if (e.key === "ArrowRight") {
                    current = (current + 1) % images.length;
                    big.src = images[current];
                }
                if (e.key === "ArrowLeft") {
                    current = (current - 1 + images.length) % images.length;
                    big.src = images[current];
                }
            }
        });

        // Generate 100 rows, 2 columns in the grid (Column 1 and 2)
        for (let i = 0; i < 100; i++) {
            // Column 1 (Editable)
            const editableCell = document.createElement('div');
            editableCell.classList.add('grid-item', 'editable', 'column-1-cell');
            editableCell.contentEditable = true;
            editableCell.dataset.row = i;
            grid.appendChild(editableCell);

            // Column 2 (Uneditable, initially empty)
            const column2Cell = document.createElement('div');
            column2Cell.classList.add('grid-item', 'readonly');
            column2Cell.dataset.row = i;
            grid.appendChild(column2Cell);

            // Generate cells for Column 3 (fixed)
            const column3OddCell = document.createElement('div');
            column3OddCell.classList.add('grid-item', 'readonly');
            column3OddCell.contentEditable = false;
            column3OddCell.dataset.row = i;
            column3.appendChild(column3OddCell);

            const column3EvenCell = document.createElement('div');
            column3EvenCell.classList.add('grid-item', 'editable');
            column3EvenCell.contentEditable = true;
            column3EvenCell.dataset.row = i;
            column3.appendChild(column3EvenCell);

            // Clicking a cell in Column 1 populates odd cells in Column 3
            editableCell.addEventListener('focus', function () {
                currentRow = i;
                updateCounters(editableCell.textContent);
                const sentences = editableCell.innerHTML.split(/\.\s*/).filter(s => s.trim() !== '');
                
                // Clear all Column 3 content first
                for (let j = 0; j < 100 * 2; j++) {
                    column3.children[j].innerHTML = "";
                }

                // Update the odd cells in Column 3 with sentences from Column 1
                for (let j = 0; j < sentences.length; j++) {
                    if (j === sentences.length - 1) {
                        column3.children[j * 2].innerHTML = sentences[j].trim();
                    } else {
                        column3.children[j * 2].innerHTML = sentences[j].trim() + '.';
                    }
                }

                // Load existing content for even cells from column3Data if it exists
                if (column3Data[currentRow]) {
                    for (let j = 0; j < column3Data[currentRow].length; j++) {
                        column3.children[j * 2 + 1].innerHTML = column3Data[currentRow][j];
                    }
                }
                
                // Rebind thumbs after content update
                rebindThumbs();
            });

            // Limit input for Column 1 (Editable)
            editableCell.addEventListener('input', function () {
                enforceLimits(editableCell, true);
                updateCounters(editableCell.textContent);
                // Rebind thumbs after input
                rebindThumbs();
            });

            // Select and show counters for even cells in Column 3 when clicked
            column3EvenCell.addEventListener('focus', function () {
                updateCounters(column3EvenCell.textContent);
            });

            // Limit input and update for Column 3 even cells
            column3EvenCell.addEventListener('input', function () {
                enforceLimits(column3EvenCell, false);
                updateCounters(column3EvenCell.textContent);
                
                if (currentRow !== null) {
                    let evenCellsContent = [];
                    let orderedContent = [];
                    let secondColumnContent = [];
                    let naturalOrderIndex = 0;

                    // Helper function to strip HTML tags for prefix detection
                    function stripHTMLTags(html) {
                        const div = document.createElement('div');
                        div.innerHTML = html;
                        return div.textContent || div.innerText || '';
                    }

                    // First pass: Process the even cells for Column 3
                    for (let j = 1; j < 100 * 2; j += 2) {
                        let content = column3.children[j].innerHTML.trim();
                        evenCellsContent.push(content);

                        let plainTextContent = stripHTMLTags(content);
                        let match = plainTextContent.match(/^(\d+)\s*(.*)/);
                        if (match) {
                            let orderIndex = parseInt(match[1]);
                            let contentWithoutPrefix = content.replace(/^(\d+)\s*/, '');
                            orderedContent.push({ orderIndex, content: contentWithoutPrefix });
                        } else {
                            secondColumnContent.push(content);
                        }
                    }

                    orderedContent.sort((a, b) => a.orderIndex - b.orderIndex);

                    // Second pass: Assign remaining cells to natural order positions
                    for (let j = 1; j < 100 * 2; j += 2) {
                        let content = column3.children[j].innerHTML.trim();
                        if (content !== "") {
                            let plainTextContent = stripHTMLTags(content);
                            let match = plainTextContent.match(/^(\d+)\s*(.*)/);
                            if (!match) {
                                while (orderedContent[naturalOrderIndex] !== undefined) {
                                    naturalOrderIndex++;
                                }
                                orderedContent.push({ orderIndex: naturalOrderIndex, content });
                                secondColumnContent = secondColumnContent.filter(item => item !== content);
                            }
                        }
                    }

                    let finalOrderedContent = orderedContent.map(item => item.content).concat(secondColumnContent);

                    // Update the second column with combined content, preserving formatting
                    grid.children[currentRow * 2 + 1].innerHTML = finalOrderedContent.length > 0 ? finalOrderedContent.join(' ') : '';

                    // Save the content of even cells for the current row in column3Data
                    column3Data[currentRow] = evenCellsContent;
                    
                    // Rebind thumbs after content update
                    rebindThumbs();
                }
            });
        }

        // Save editable data to a TXT file
        function saveData() {
            const data = [];

            for (let i = 0; i < 100; i++) {
                const column1Content = grid.children[i * 2].innerHTML;

                if (column3Data[i]) {
                    let lastFilledIndex = -1;
                    
                    for (let j = 0; j < column3Data[i].length; j++) {
                        if (column3Data[i][j].trim() !== '') {
                            lastFilledIndex = j;
                        }
                    }

                    let evenCellsContent = [];
                    for (let j = 0; j <= lastFilledIndex; j++) {
                        evenCellsContent.push(column3Data[i][j].trim() !== '' ? column3Data[i][j] : 'EMPTY.');
                    }
                    data.push(`Row ${i + 1} Column 1): ${column1Content}`);
                    data.push(`Row ${i + 1} Column 3 (Even): ${evenCellsContent.join('. ')}`);
                } else {
                    data.push(`Row ${i + 1} Column 1): ${column1Content}`);
                    data.push(`Row ${i + 1} Column 3 (Even): EMPTY.`);
                }
            }

            const now = new Date();
            const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
            const firstCellContent = grid.children[0].textContent.trim().split(' ')[0] || 'grid_data';
            const filename = `${firstCellContent}_${timestamp}.txt`;

            const blob = new Blob([data.join('\n')], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Load data from a TXT file
        function loadData() {
            const input = document.getElementById('fileInput');
            input.click();
            input.addEventListener('change', function () {
                const file = input.files[0];
                const reader = new FileReader();
                reader.onload = function () {
                    const lines = reader.result.split('\n');
                    column3Data = {};
                    images = []; // Reset images array

                    lines.forEach((line, index) => {
                        const rowIndex = Math.floor(index / 2);
                        const content = line.split('): ')[1];

                        if (index % 2 === 0) {
                            grid.children[rowIndex * 2].innerHTML = content;
                        } else {
                            const evenCells = content.split('. ').map(cell => cell === 'EMPTY.' ? '' : cell);
                            column3Data[rowIndex] = evenCells;

                            for (let j = 0; j < evenCells.length; j++) {
                                column3.children[rowIndex * 2 + 1 + j * 2].innerHTML = evenCells[j];
                            }

                            // Process content for Column 2 (same logic as before)
                            let orderedContent = [];
                            let naturalOrderContent = [];
                            let naturalOrderIndex = 0;

                            function stripHTMLTags(html) {
                                const div = document.createElement('div');
                                div.innerHTML = html;
                                return div.textContent || div.innerText || '';
                            }

                            evenCells.forEach((cellContent) => {
                                let plainTextContent = stripHTMLTags(cellContent);
                                let match = plainTextContent.match(/^(\d+)\s*(.*)/);
                                if (match) {
                                    let orderIndex = parseInt(match[1]);
                                    let contentWithoutPrefix = cellContent.replace(/^(\d+)\s*/, '');
                                    orderedContent.push({ orderIndex, content: contentWithoutPrefix });
                                } else if (cellContent !== "") {
                                    naturalOrderContent.push(cellContent);
                                }
                            });

                            orderedContent.sort((a, b) => a.orderIndex - b.orderIndex);

                            naturalOrderContent.forEach((cellContent) => {
                                orderedContent.push({ orderIndex: naturalOrderIndex++, content: cellContent });
                            });

                            let finalOrderedContent = orderedContent.map(item => item.content);
                            grid.children[rowIndex * 2 + 1].innerHTML = finalOrderedContent.join(' ');
                        }
                    });
                    
                    // Rebuild images array and rebind thumbs after loading
                    document.querySelectorAll('.thumb').forEach(thumb => {
                        const src = thumb.dataset.src;
                        if (src && !images.includes(src)) {
                            images.push(src);
                        }
                    });
                    rebindThumbs();
                };
                reader.readAsText(file);
            });
        }

        // Scroll functions
        function adjustEditablePositionOnFocus() {
            const editables = document.querySelectorAll('.editable');
            editables.forEach(editable => {
                editable.addEventListener('focus', () => {
                    setTimeout(() => {
                        editable.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                });
            });
        }

        function adjustColumnThreeToTop() {
            const editables = document.querySelectorAll('.column-1-cell');
            editables.forEach(editable => {
                editable.addEventListener('focus', () => {
                    setTimeout(() => {
                        const column3 = document.querySelector('.column-3');
                        if (column3) {
                            column3.scrollTo({
                                top: 0,
                                behavior: 'smooth'
                            });
                        }
                    }, 300);
                });
            });
        }

        window.addEventListener('DOMContentLoaded', adjustEditablePositionOnFocus);      
        window.addEventListener('DOMContentLoaded', adjustColumnThreeToTop);     
        
        document.addEventListener('focusout', function(e) {
            if (e.target.classList.contains('editable')) {
                setTimeout(function() {
                    window.scrollTo(0, 0);
                }, 300);
            }
        });

        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            document.addEventListener('focusin', (e) => {
                if (e.target.classList.contains('editable')) {
                    window.scrollTo(0, e.target.offsetTop - 50);
                }
            });
        }

        // Initial rebind on page load
        document.addEventListener('DOMContentLoaded', rebindThumbs);
    </script>
</body>
</html>
